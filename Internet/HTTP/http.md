# HTTP (HyperText Transfer Protocol)?
- 텍스트 기반의 통신 규약으로 **인터넷에서 데이터를 주고받을 수 있는 프로토콜**이다.<br>
이렇게 규약을 정해두었기 때문에 모든 프로그램이 이 규약에 맞춰 개발해서 서로 정보를 교환할 수 있게 되었다.
  
## HTTP 동작
- 클라이언트 즉, 사용자가 브라우저를 통하여 어떠한 서비스를 url을 통하거나 다른 것을 통해서 **요청**(request)을 하면 서버에서는 해당 요청사항에 맞는 결과를 찾아서 사용자에게 **응답**(response)하는 형태로 동작한다.
  - 요청 : ***client -> server***
  - 응답 : ***server -> client***
- HTML 문서만이 HTTP 통신을 위한 유일한 정보 문서는 아니다. Plain text로 부터 JSON 데이터 및 XML과 같은 형태의 정보도 주고 받을 수 있으며,<br>
보통은 클라이언트가 어떤 정보를 **HTML 형태**로 받고 싶은지, **JSON 형태**로 받고 싶은지 명시해주는 경우가 많다.

## HTTP 특징
### 📍 ***Connectless***
***Connectless***(비연결성)은 클라이언트와 서버가 한 번 연결을 맺은 후,<br>
클라이언트 **요청**에 대해 서버가 **응답**을 마치면 맺었던 연결을 끊어 버리는 성질을 말한다.

> **🙋🏻‍♂️ : HTTP 프로토콜은 왜 한 번 맺은 연결을 끊어버리는건가요?**
> 
> **🧠 : HTTP는 인터넷 상에서 불특정 다수의 통신 환경을 기반으로 설계되었습니다.**<br>
         **만약 서버에서 다수의 클라이언트와 연결을 계속 유지해야 한다면, 이에 따른 많은 리소스가 발생하게 됩니다.**<br>
         **따라서 연결을 유지하기 위한 리소스를 줄이면 더 많은 연결을 할 수 있으므로 비연결적인 특징을 갖습니다.**
>
> **🤷🏻 : 이로 인한 단점은 없나요?**
> 
> **🧠 : 물론 이로 인한 단점도 존재합니다.**<br>
**서버는 클라이언트를 기억하고 있지 않으므로 동일한 클라이언트의 모든 요청에 대해서 매번 새로운 연결을 시도/해제의 과정을 거쳐야하므로,**<br>
**연결/해제에 대한 오버헤드가 발생한다는 단점이 있습니다.**<br>

#### HTTP의 기능(추가)
1. ***keep-alive*** `HTTP 1.1부터 지원하는 기능`<br>
방금 언급했듯이 HTTP는 1번의 요청에 대해 1번의 응답 하는 것을 기준으로 설계되었다.<br>
요즘 웹사이트들을 보면 하나의 페이지에 수십개 이미지, css 파일, js 파일이 있는 것을 볼 수 있다.<br><br>
그러나 **1요청 1응답** 기준이라면 여러번 연결을 끊었다 붙였다 해야함 굉장히 비효율적이다.<br><br>
그걸 보안하기 위해서 나온 것이 이 **keep-alive**라는 기능인데,<br>
이 **keep-alive**의 지원으로 지정된 시간동안 연결을 끊지않고 연결된 상태를 유지할 수 있다.<br>
내 클라이언트가 재요청하면 새로운 연결이 아닌 연결된 것을 이용하게 된다.<br>
<br>

### 📍 ***Stateless***


<div align="center">
  
<img src="https://media.vlpt.us/post-images/surim014/e0aa5520-2d59-11ea-86da-fb3b00230640/image.png">

</div>

## 서버와 클라이언트
- **서버** : 어떠한 자료에 대한 접근을 관리하는 네트워크 상의 시스템 **(요청에 대한 응답을 보내준다.)**
- **클라이언트** : 그 자료에 접근할 수 있는 프로그램  
e.g.) 웹 브라우저, 핸드폰 어플리케이션 등등

클라이언트 프로그램에서 사용자가 회원가입을 시도하게 되면, 서버로 회원정보를 보내게 되고 서버는 회원 정보를 저장해주기도 한다.<br>
이 과정에서 클라이언트와 서버 간의 교류가 HTTP라는 규약을 이용하여 발생하게 된다.

### Request (요청)
- **클라이언트가 서버에게 연락하는 것**을 요청이라고 하며 요청을 보낼때는 요청에 대한 정보를 담아 서버로 보낸다.

### Request Method (요청의 종류)
- **GET** : 자료를 **요청**할 때 사용
- **POST** : 자료의 **생성**을 요청할 때 사용
- **PUT** : 자료의 **수정**을 요청할 때 사용
- **DELETE** : 자료의 **삭제**를 요청할 때 사용

## Request HTTP 메시지 예시
```
GET https://github.com/songyouhyun HTTP/1.1					  // 시작줄
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...			  // 헤더
Upgrade-Insecure-Requests: 1
```
### 1. 시작줄 (첫 줄)
첫 줄은 시작줄로 **메서드 구조 버전**으로 구성되었다.
- GET : HTTP Method
- https://github.com/songyouhyun : 사이트 주소
- HTTP/1.1 : HTTP 버전

### 2. 헤더 (두 번째 줄부터)
두번째 줄부터는 헤더이며 **요청에 대한 정보**를 담고 있다. User-Agent, Upgrade-Insecure-Requests 등등이 헤더에 해당되며 헤더의 종류는 매우 많다.

### 3. 본문 (헤더에서 한 줄 띄고)
본문은 **요청을 할 때 함께 보낼 데이터를 담는 부분**이다. 예시에는 단순히 주소로만 요청을 보내고 있고 따로 데이터를 담아 보내지 않기 때문에 본문이 비어있다.

## Response(응답)
**서버가 요청에 대한 답변을 클라이언트에게 보내는 것**을 응답이라고 한다.

## Status Code (상태 코드)
상태 코드에는 굉장히 많은 종류가 있다. 모두 숫자 세 자리로 이루어져 있으며, 아래와 같이 크게 다섯 부류로 나눌 수 있다.
- **1XX(조건부 응답)** : 요청을 받았으며 작업을 계속한다.
- **2XX(성공)** : 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리했음을 가리킨다.
- **3XX(리다이렉션 완료)** : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.
- **4XX(요청 오류)** : 클라이언트에 오류가 있음을 나타낸다.
- **5XX(서버 오류)** : 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타낸다.

## Response HTTP 메시지 예시
```
HTTP/1.1 200 OK					// 시작줄
Connection: keep-alive				// 헤더
Content-Encoding: gzip												 
Content-Length: 35653
Content-Type: text/html;

<!DOCTYPE html><html lang="ko" data-reactroot=""><head><title...
```

### 1. 시작줄 (첫 줄)
첫 줄은 **버전 상태코드 상태메시지**로 구성되어 있다. 200은 성공적인 요청이었다는 뜻이다.
### 2. 헤더 (두 번째 줄부터)
두 번째 줄부터는 헤더로 **응답에 대한 정보를 담고 있다.**
### 3. 본문 (헤더 뒤부터)
응답에는 대부분의 경우 본문이 있다. 보통 데이터를 요청하고 응답 메시지에는 **요청한 데이터를 담아서 보내주기 때문이다. 응답 메시지에 HTML이 담겨 있는데 이 HTML을 받아 브라우저가 화면에 렌더링한다.**
